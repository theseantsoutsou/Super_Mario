//////REQ1//////
While Sprout, Sapling, and Mature are stages of a tree, they have unique spawning abilities. To obey the Single-Responsibility
Principle, it was decided to make them separate classes that inherit the Ground Class.
As Sprout can spawn a Goomba, it implied that it would have a dependency, that is, a method to potentially
spawn a Goomba when conditions are met.
Similarly, a Sapling can drop coins every turn, which implies that Sapling knows about Coin, and therefore has
a dependency on the Coin Class.
Lastly, a Tree can spawn a Koopa, which is responsible for its dependency on the Koopa Class.

As Sprout grows into Sapling, Sapling grows into Tree, and Tree can spawn Sprouts or become Dirt, Sprout has a
dependency on Sapling, Sapling has a dependency on Tree, and Tree has dependencies on Sprout and Dirt.


//////REQ2//////
The JumpAction is implemented similarly to the existing class AttackAction. It also inherits from the base
class Action. It has an attribute target of class Ground which forms its association with the Ground class.
This is done to obey the Liskov Substitution Principle. In reality, JumpAction will only target Wall, Sprout,
Sapling, and Tree which all inherit from the Ground class. Success rates and fall damages will be added as
attributes to the relevant Ground subclasses as they have unique values. These values will then be retrieved
when JumpAction.execute() is called. As JumpAction already has an association with the Ground class,
this design does not add on to the dependencies between classes, and therefore follows the idea of
reducing dependencies (ReD).

To further implement the ReD principle, JumpAction will check the consumption of SuperMushroom via the
Actor method hasCapabilities() to check if the Player has the Status TALL. Since Action has an existing
dependency on Actor, this method does not add more dependencies.


//////REQ3//////
Goomba and Koopa would inherit certain aspects of the Actor class as they both contain attributes that are
shared amongst other characters such as health and the ability to move around (with the exception of Toad).
As a result, they would have an inheritance relationship with the Actor class. Additionally, Goomba and Koopa
have relationships with Sprout and Tree where a Sprout or a Tree have the chance to spawn a Goomba or
Koopa respectively.

Koopa would have an association with Super Mushroom as when the shell of a Koopa is destroyed, a
Super Mushroom is dropped.

Futhermore, Goomba and Koopa would implement the Behaviour interface which allows them to have their own
'objectives' such as killing the player.


//////REQ4//////
Both Super Mushroom and Power Star are objects that the player can use to gain a benefit/advantage in the game,
as a result, they would inherit aspects of the Item class.

Super Mushroom and Power Star would implement the TradableItem interface which would list them as
items Toad has a pontential to carry when the player interacts with him in order to trade.

Koopa would have an association with Super Mushroom as when the shell of a Koopa is destroyed, a
Super Mushroom is dropped.

A class called FlattenAction would create the functionality where whenever, the player character moves
to higher ground, instead of a JumpAction, the target position would be flattened and become dirt. This class
would have an association with the abstract class Ground as it would turn Ground objects (Sapling, Sprout, Tree, Wall)
into Dirt.

FlattenAction would also inherit attributes of the abstract class Action as it is an action the player
can make after using a Power Star item.

//////REQ5//////
- If wallet were an attribute of the Player (or any sub-class of Actor) as it is in the initial design.
it would be difficult for a TradeAction to access that attribute through calls to the Actor type. Instead, by making the
Wallet class a Singleton design pattern with a static getInstance() method, the wallet can be accessed easily from within
the TradeAction.

- Few changes to variable and method names to make them more descriptive/obvious.

- Implemented a TradeableItemInventory. This was forgotten in the initial design, but is necessary to access the methods of the
TradableItem interface in places where only an Item type can is supplied. Furthermore, the Dependency Inversion Principle in
not fully realised in the design without the inclusion of this class.

//////REQ6//////
- No difference in SpeakAction

//////REQ7//////
The ResetManager class manages a list of objects that implements the Resettable interface.
For the purpose of resetting the game, Player, Toad, Goomba, Koopa, and Tree will implement the Resettable Interface.
Doing so supports the Dependency Inversion Principle, as ResetManager does not directly associate with any low-level modules,
but only associates with the Resettable Interface itself. The list of Resettable in ResetManager would then contain any resettable objects.
ResetManager would then have a dependency to GameMap via a method such that it would be able to reset the GameMap to its initial state.
